#include "%UNIT_NAME%Lexer.h"

#include <array>

#include "%UTF8_LIB_PATH%/utf8.h"

constexpr size_t ERROR_STATE = (size_t)-1;
const std::array<std::string, %TOKEN_TYPE_COUNT%> TOKEN_TYPE_TO_STRING {
%TOKEN_TYPE_STRINGS%
};

void %MODULE_NAMESPACE%::CharacterPosition::advance(const char32_t consumed) {
    if (consumed == (char32_t)'\n') {
        this->line++;
        this->column = 1;
    } else {
        this->column++;
    }
}

bool %MODULE_NAMESPACE%::Token::is_ignored() const {
    return this->type > TokenType::%LAST_NORMAL_TOKEN%;
}

%MODULE_NAMESPACE%::%UNIT_NAME%Lexer::%UNIT_NAME%Lexer(std::istream& input) : input{input}, curr_position{} {
}

%MODULE_NAMESPACE%::Token %MODULE_NAMESPACE%::%UNIT_NAME%Lexer::next_token() {
    %PRE_STATE_MACHINE_FALLBACK%
    const CharacterPosition token_start = this->curr_position;
    size_t state = 0;
    std::u32string identifier = U"";
    char32_t curr = this->get_char();
    if (this->end()) {
        return Token{Token::TokenType::END_OF_FILE, U"", token_start};
    }

    while (true) {
        this->cache.push(curr);
        switch(state) {
%STATES%%ERROR_STATE%
        }
        identifier += this->cache.top();
        this->curr_position.advance(this->cache.top());
        this->cache.pop();
        curr = this->get_char();
    }
}

%MODULE_NAMESPACE%::Token %MODULE_NAMESPACE%::%UNIT_NAME%Lexer::next_unignored_token() {
    Token unignored{};

    do {
        unignored = this->next_token();
    } while (unignored.is_ignored());

    return unignored;
}

bool %MODULE_NAMESPACE%::%UNIT_NAME%Lexer::end() const {
    return this->input.eof() && this->cache.empty();
}

char32_t %MODULE_NAMESPACE%::%UNIT_NAME%Lexer::get_char() {
    if (!this->cache.empty()) {
        char32_t cached = this->cache.top();
        this->cache.pop();

        return cached;
    }

    return utf8::get_unicode_char(this->input);
}

%RESTORE_FALLBACK_FUNC%

std::ostream& %MODULE_NAMESPACE%::operator<<(std::ostream& output, const CharacterPosition& to_print) {
    return output << "[Ln " << to_print.line << ", Col " << to_print.column << "]";
}

std::ostream& %MODULE_NAMESPACE%::operator<<(std::ostream& output, const Token& to_print) {
    return output << to_print.position << " " << to_print.type << " " << to_print.identifier;
}

std::ostream& %MODULE_NAMESPACE%::operator<<(std::ostream& output, const Token::TokenType to_print) {
    return output << TOKEN_TYPE_TO_STRING.at((size_t)to_print);
}